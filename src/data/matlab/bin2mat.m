function [D, group_id, group_offset] = bin2mat(name)
% load a binary format data, which can be generated by ./bin/recordio2bin
  function result = grep(name, pattern)
  [ret, result] = system(...
    ['grep ', pattern, ' ', name, '.info | awk ''{print $2}''']);
  assert(ret == 0);
  result(end) = [];
  end

type = grep(name, 'type');
n = str2num(grep(name, 'end'));
row_major = all(grep(name, 'row_major') == 'true');
sizeof_v = str2num(grep(name, 'sizeof_value'));

if strfind(type, 'DENSE')
  assert(row_major);
  assert(sizeof_v == 8);
  D = load_bin([name, '.value'], 'double');
  D = reshape(D, n(2), n(1))';
elseif strfind(type, 'SPARSE')

  if exist([name, '.key'], 'file')
    group_id = str2num(grep(name, 'group_id'));
    begin = sscanf(grep(name, 'fea_begin'), '%lu');
    [begin, ix] = sort(begin);
    group_id = group_id(ix);
    % begin = str2num(; %, 'uint64');
    % begin = uint64(begin)'
    % return
    % e = str2num(grep(name, 'feature_end'), 'uint64');
    key = load_bin([name, '.key'], 'uint64');
    group_offset = zeros(length(begin)+1, 1);
    group_offset(end) = length(key) + 1;
    for i = 1 : length(begin)
      group_offset(i) = find(key == begin(i), 1, 'first');
    end
    clear key
    % group_offset
  end

  sizeof_i = str2num(grep(name, 'sizeof_index'));
  assert(sizeof_i == 4);

  j = load_bin([name '.index'], 'uint32');
  J = double(j) + 1;
  clear j

  i = load_bin([name '.offset'], 'uint64');
  I = zeros(length(J), 1);
  for k = 1 : length(i) - 1
    I(i(k)+1 : i(k+1)) = k;
  end
  clear i

  if strfind(type, 'SPARSE_BINARY')
    D = sparse(I, J, 1);
  else
    V = load_bin([name '.value'], 'double');
    D = sparse(I, J, V);
  end

end

end
